// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["driverAdapters"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? @db.Text
    access_token             String? @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id                    String                  @id @default(cuid())
    name                  String?
    email                 String?                 @unique
    emailVerified         DateTime?
    image                 String?
    color                 String?
    adminComment          String?
    accounts              Account[]
    sessions              Session[]
    userGameProfiles      UserGameProfile[]
    userRoles             UserRole[]
    userStreams           UserStream[]
    tournamentSeries      TournamentSeries[]
    TournamentParticipant TournamentParticipant[]
    TournamentMatchStream TournamentMatchStream[]
}

model UserGameProfile {
    id            String   @id @default(cuid())
    userId        String
    user          User     @relation(fields: [userId], references: [id])
    platformId    String
    platform      Platform @relation(fields: [platformId], references: [id])
    statProfileId String // ID of aoe2 account for aoe2companion
    mainAccount   Boolean

    @@unique([userId, mainAccount]) // A user can only have one main account
}

model Role {
    id             String  @id @default(cuid())
    name           String
    comment        String?
    selfAssignable Boolean
    modAssignable  Boolean

    userRoles UserRole[]
}

model UserRole {
    id         String    @id @default(cuid())
    userId     String
    user       User      @relation(fields: [userId], references: [id])
    roleId     String
    role       Role      @relation(fields: [roleId], references: [id])
    assignedAt DateTime  @default(now())
    expiresAt  DateTime?
    comment    String?

    @@unique([userId, roleId])
}

model UserStream {
    id         String   @id @default(cuid())
    userId     String
    user       User     @relation(fields: [userId], references: [id])
    platformId String
    platform   Platform @relation(fields: [platformId], references: [id])
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model Platform {
    id          String @id @default(cuid())
    name        String
    type        String // game, stream, social, etc.
    urlTemplate String

    userGameProfiles UserGameProfile[]
    userStreams      UserStream[]

    @@unique([name, type])
}

model BaseMap {
    id           String @id @default(cuid())
    name         String
    description  String
    thumbnailUrl String

    maps Map[]
}

model Map {
    id           String @id @default(cuid())
    name         String
    description  String
    thumbnailUrl String

    baseMapId String
    baseMap   BaseMap @relation(fields: [baseMapId], references: [id])
    Game      Game[]
}

model Civ {
    id           String @id @default(cuid())
    name         String
    description  String
    content      String
    thumbnailUrl String
}

model TournamentSeries {
    id           String       @id @default(cuid())
    name         String
    ownerId      String
    owner        User         @relation(fields: [ownerId], references: [id])
    displayOrder Int
    description  String
    tournament   Tournament[]
}

model TournamentMatchMode {
    id              String            @id @default(cuid())
    mode            String
    gameCount       Int // Number of games in match bo7 = 7 etc.
    tournament      Tournament[]
    groups          TournamentGroup[]
    TournamentMatch TournamentMatch[]
}

enum RegistrationMode {
    INDIVIDUAL
    TEAM
    ADMIN
}

enum TournamentStatus {
    PENDING
    ACTIVE
    FINISHED
    CANCELLED
}

enum MatchStatus {
    SCHEDULED
    IN_PROGRESS
    COMPLETED
    CANCELLED
}

enum StreamStatus {
    SCHEDULED
    LIVE
    COMPLETED
    CANCELLED
}

enum ParticipantStatus {
    REGISTERED
    CHECKED_IN
    DISQUALIFIED
    WITHDRAWN
}

enum TeamStatus {
    ACTIVE
    DISQUALIFIED
    WITHDRAWN
}

enum TournamentStageType {
    GROUP
    BRACKET
}

enum BracketType {
    SINGLE_ELIMINATION
    DOUBLE_ELIMINATION
}

model Tournament {
    id                    String                  @id @default(cuid())
    urlKey                String
    registrationMode      RegistrationMode
    tournamentSeriesId    String
    tournamentSeries      TournamentSeries        @relation(fields: [tournamentSeriesId], references: [id])
    matchModeId           String
    matchMode             TournamentMatchMode     @relation(fields: [matchModeId], references: [id])
    description           String                  @db.Text
    isTeamBased           Boolean
    startDate             DateTime
    endDate               DateTime?
    participantsLimit     Int?
    registrationStartDate DateTime?
    registrationEndDate   DateTime?
    status                TournamentStatus
    isVisible             Boolean
    sections              TournamentSection[]
    teams                 TournamentTeam[]
    stages                TournamentStage[]
    TournamentParticipant TournamentParticipant[]
}

model TournamentSection {
    id           String     @id @default(cuid())
    tournamentId String
    tournament   Tournament @relation(fields: [tournamentId], references: [id])
    type         String // group / prices / how to start etc.
    isVisible    Boolean
    content      String?    @db.Text // markdown

    @@unique([tournamentId, type])
}

model TournamentTeam {
    id                         String                       @id @default(cuid())
    name                       String
    comment                    String?                      @db.Text
    tournamentId               String
    tournament                 Tournament                   @relation(fields: [tournamentId], references: [id])
    status                     TeamStatus                   @default(ACTIVE)
    rosterSizeLimit            Int?
    seedNumber                 Int?
    TournamentParticipant      TournamentParticipant[]
    TournamentMatchParticipant TournamentMatchParticipant[]

    captainId String?
    captain   TournamentParticipant? @relation(name: "TeamCaptain", fields: [captainId], references: [id])

    @@unique([tournamentId, name])
}

model TournamentStage {
    id              String            @id @default(cuid())
    tournamentId    String
    tournament      Tournament        @relation(fields: [tournamentId], references: [id])
    name            String
    type            TournamentStageType
    isActive        Boolean           @default(false)
    startDate       DateTime?
    endDate         DateTime?
    description     String?
    
    // For bracket stages
    bracketType     BracketType?
    bracketSize     Int?             // Number of participants in bracket
    isSeeded        Boolean          @default(true)
    
    groups          TournamentGroup[]
    brackets        TournamentBracket[]

    @@unique([tournamentId, type])
}

model TournamentBracket {
    id              String            @id @default(cuid())
    stageId         String
    stage           TournamentStage   @relation(fields: [stageId], references: [id])
    name            String
    displayOrder    Int
    isActive        Boolean           @default(false)
    startDate       DateTime?
    endDate         DateTime?
    description     String?           @db.Text
    
    // Bracket configuration
    bracketType     BracketType
    bracketSize     Int              // Number of participants in bracket
    isSeeded        Boolean          @default(true)
    isManualSeeding Boolean          @default(false) // If true, admin can manually set matchups
    
    bracketNodes    TournamentBracketNode[]

    @@unique([stageId, displayOrder])
}

model TournamentBracketNode {
    id              String            @id @default(cuid())
    bracketId       String
    bracket         TournamentBracket @relation(fields: [bracketId], references: [id])
    round           Int               // Round number in bracket
    position        Int               // Position in round
    isWinnerBracket Boolean           @default(true) // For double elimination
    parentNodeId    String?           // Reference to parent node in bracket
    parentNode      TournamentBracketNode? @relation("BracketNodeParent", fields: [parentNodeId], references: [id])
    childNodes      TournamentBracketNode[] @relation("BracketNodeParent")
    matchId         String?
    match           TournamentMatch?  @relation(fields: [matchId], references: [id])
    
    // Admin control fields
    isManualMatch   Boolean           @default(false) // If true, this match was manually created
    adminComment    String?           @db.Text // For admin notes about this node

    @@unique([bracketId, round, position])
}

model TournamentGroup {
    id String @id @default(cuid())

    stageId String
    stage   TournamentStage @relation(fields: [stageId], references: [id])

    displayOrder Int
    name         String
    description  String?    @db.Text
    matchModeId  String
    matchMode    TournamentMatchMode @relation(fields: [matchModeId], references: [id])

    isTeamBased                Boolean // can override tournament setting
    TournamentGroupParticipant TournamentGroupParticipant[]
    matches                    TournamentMatch[]

    @@unique([stageId, name])
    @@unique([stageId, displayOrder])
}

model TournamentParticipant {
    id                         String                       @id @default(cuid())
    tournamentId               String
    tournament                 Tournament                   @relation(fields: [tournamentId], references: [id])
    teamId                     String? // Optional for individual tournaments
    team                       TournamentTeam?              @relation(fields: [teamId], references: [id])
    userId                     String?
    user                       User?                        @relation(fields: [userId], references: [id])
    status                     ParticipantStatus            @default(REGISTERED)
    seedNumber                 Int?
    registrationDate           DateTime                     @default(now())
    TournamentGroupParticipant TournamentGroupParticipant[]
    TournamentMatchParticipant TournamentMatchParticipant[]
    TournamentTeam             TournamentTeam[]             @relation("TeamCaptain")

    @@index([tournamentId])
}

model TournamentGroupParticipant {
    id                      String                @id @default(cuid())
    tournamentGroupId       String
    tournamentGroup         TournamentGroup       @relation(fields: [tournamentGroupId], references: [id])
    tournamentParticipantId String
    tournamentParticipant   TournamentParticipant @relation(fields: [tournamentParticipantId], references: [id])
    displayOrder            Int
    comment                 String?
    seedNumber              Int?

    @@unique([tournamentGroupId, tournamentParticipantId])
}

model TournamentMatch {
    id String @id @default(cuid())

    // A match must belong to either a group or be part of a bracket node
    groupId String?
    group   TournamentGroup? @relation(fields: [groupId], references: [id])

    matchDate   DateTime
    civDraftKey String
    mapDraftKey String

    status       MatchStatus
    comment      String?           @db.Text
    adminComment String?           @db.Text

    // Match creation info
    isManualMatch Boolean           @default(false) // If true, this match was manually created
    createdBy     String?           // User ID who created the match
    createdAt     DateTime          @default(now())

    TournamentMatchMode        TournamentMatchMode?         @relation(fields: [tournamentMatchModeId], references: [id])
    tournamentMatchModeId      String?
    TournamentMatchParticipant TournamentMatchParticipant[] // Contains the two participants/teams
    Game                       Game[]
    TournamentMatchStream      TournamentMatchStream[]
    bracketNodes               TournamentBracketNode[]      // Links to bracket nodes that use this match

    @@unique([groupId]) // Ensures a match belongs to either a group or is part of a bracket node
}

model TournamentMatchStream {
    id String @id @default(cuid())

    tournamentMatchId String
    tournamentMatch   TournamentMatch @relation(fields: [tournamentMatchId], references: [id])

    streamerId String
    streamer   User   @relation(fields: [streamerId], references: [id])

    status              StreamStatus
    scheduledStartTime  DateTime?
    streamUrl           String?
    scheduledStreamLive Boolean
}

model TournamentMatchParticipant {
    id                String                 @id @default(cuid())
    matchId           String
    match             TournamentMatch        @relation(fields: [matchId], references: [id])
    participantId     String?
    participant       TournamentParticipant? @relation(fields: [participantId], references: [id])
    teamId            String?
    team              TournamentTeam?        @relation(fields: [teamId], references: [id])
    isWinner          Boolean                @default(false)
    score             Int?                   // Optional score for the participant/team

    // Relations for games
    gamesWon          Game[]                 @relation("GameWinner")
    gamesLost         Game[]                 @relation("GameLoser")

    @@unique([matchId, participantId])
    @@unique([matchId, teamId])
}

model Game {
    id      String          @id @default(cuid())
    matchId String
    match   TournamentMatch @relation(fields: [matchId], references: [id])

    mapId String
    map   Map    @relation(fields: [mapId], references: [id])

    gameDate DateTime
    recUrl   String?        @db.Text

    winnerId String
    winner   TournamentMatchParticipant @relation("GameWinner", fields: [winnerId], references: [id])

    loserId String
    loser   TournamentMatchParticipant @relation("GameLoser", fields: [loserId], references: [id])
}
